<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Miyagi</title>
  <subtitle>A Heroku inspired journal of application development</subtitle>
  <id>http://miyagijournal.com/</id>
  <link href="http://miyagijournal.com/"/>
  <link href="http://miyagijournal.com/articles.atom" rel="self"/>
  <updated>2012-12-11T00:00:00-08:00</updated>
  <entry>
    <title>The Tortoise and The Octocat</title>
    <link rel="alternate" href="http://miyagijournal.com/articles/9-the-tortoise-and-the-octocat.html"/>
    <id>http://miyagijournal.comarticles/9-the-tortoise-and-the-octocat.html</id>
    <published>2012-12-11T00:00:00-08:00</published>
    <updated>2012-12-11T00:00:00-08:00</updated>
    <author>
      <name>Mattt Thompson</name>
    </author>
    <summary type="html">Programmers are the legislators, the authors, the arbiters of our digital existence. And in a world where the digital is increasingly inseparable from physical, the implication is clear: our decisions in code today affect our world tomorrow.</summary>
    <content type="html">&lt;p&gt;Software has social implications. Conversations about system architecture &amp;amp; design patterns, of standards &amp;amp; protocols: these are not merely academic exercises. Programmers are the legislators, the authors, the arbiters of our digital existence. And in a world where the digital is increasingly inseparable from physical, the implication is clear: our decisions in code today affect our world tomorrow.&lt;/p&gt;

&lt;h2&gt;Revision Control&lt;/h2&gt;

&lt;p&gt;Consider the difference between &lt;a href="http://git-scm.com"&gt;Git&lt;/a&gt; and &lt;a href="http://subversion.apache.org"&gt;Subversion&lt;/a&gt;. Although they both accomplish the task of &lt;a href="http://en.wikipedia.org/wiki/Revision_control"&gt;revision control&lt;/a&gt;, they go about it in completely different ways, and those differences are culturally significant.&lt;/p&gt;

&lt;p&gt;Subversion is designed to have a central repository that clients synchronize with each time they want to commit a change. Git, on the other hand, uses a distributed architecture, in which there is no canonical repository and changes are synchronized by exchanging patches from peer to peer.&lt;/p&gt;

&lt;p&gt;While this may seem like a minor architectural difference, the social implications are immense. Like that old &lt;a href="http://en.wikipedia.org/wiki/Chaos_theory"&gt;Chaos Theory&lt;/a&gt; chestnut about a butterfly flapping its wings, even the slightest aspect can have a profound impact on the overall system (though it is difficult to anticipate or even understand these effects).&lt;/p&gt;

&lt;h2&gt;Impact&lt;/h2&gt;

&lt;p&gt;Working with Subversion was slow, stressful, and frustrating. An Internet connection was required to get anything done, since the only way to commit -- even incremental changes to your working copy -- required synchronization with the server. Branching was cumbersome, and so committing directly to the trunk was not uncommon. But that had its own problems, whether that was a conflict from someone else&amp;#39;s commit stopping you in your tracks, or the threat of your stashed changes breaking the production build somewhere down the line.&lt;/p&gt;

&lt;p&gt;As a result of these small annoyances, teams using SVN often cultivated a culture of fear, intimidation, and isolation. Code became more difficult to write, which had a stifling effect on open source participation. Imagine the thousands of useful features went unwritten because of the cognitive and logistical overhead of collaboration with Subversion.&lt;/p&gt;

&lt;p&gt;On the other hand, Git sparked a so-called &amp;quot;social coding&amp;quot; revolution. &lt;a href="https://github.com"&gt;GitHub&lt;/a&gt; has transcended its utility of code storage to become the de facto social network for software developers. And as a result, the open source world has never been more connected. &lt;/p&gt;

&lt;p&gt;Git succeeded in a way that Subversion never could, and it has everything to do with its architecture.&lt;/p&gt;

&lt;h2&gt;Decentralization&lt;/h2&gt;

&lt;p&gt;As a decentralized system, there are few constraints on how code is be managed. Rather than there being a canonical source of truth, each repository tells its own story, with alternative histories that can be joined up later with others by massaging out the details. (But they don&amp;#39;t have to.)&lt;/p&gt;

&lt;p&gt;One of the most interesting consequences of being decentralized is that developers are forced to communicate amongst themselves to negotiate how they work together. Pull Requests form the atomic unit of collaboration, as well as a forum in which teams can discuss the shape and direction of their work. &amp;quot;Pull Requests Welcome&amp;quot; has become a universal slogan that invites everyone to contribute however they can.&lt;/p&gt;

&lt;p&gt;Greater participation means better software, which, in turn, has deep implications on the kinds of relationships and institutions that fill our lives.&lt;/p&gt;

&lt;p&gt;This is not at all to say that Subversion is all bad and Git is all good. SVN was a massive improvement over CVS, which itself revolutionized software development as the first popular client-server version control system. And Git... well, surely there are some things Git could do better, and there are new paradigms we&amp;#39;ve only yet to discover.&lt;/p&gt;

&lt;h2&gt;Software as Culture&lt;/h2&gt;

&lt;p&gt;Revision control is but one example of our decisions as developers affecting more than our code. Consider the organizational implications of embracing open-source libraries vs. a proprietary application stack. Or of developing on Unix versus Windows. Or of using Ruby vs. Java.&lt;/p&gt;

&lt;p&gt;One choice is not strictly better than any other, but they are indeed &lt;em&gt;cultural&lt;/em&gt; choices.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s not often that we think about the social implications of choosing or development tools or application technologies. Perhaps it&amp;#39;s time we started. The decisions we make in our text editors can fundamentally change our relationship with the people and world around us.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Process Partitioning in Distributed Systems</title>
    <link rel="alternate" href="http://miyagijournal.com/articles/8-process-partitioning-in-distributed-systems.html"/>
    <id>http://miyagijournal.comarticles/8-process-partitioning-in-distributed-systems.html</id>
    <published>2012-12-06T00:00:00-08:00</published>
    <updated>2012-12-06T00:00:00-08:00</updated>
    <author>
      <name>Ryan Smith</name>
    </author>
    <summary type="html">Assigning a group of worker processes to operate, in parallel, against a large dataset is a very efficient approach to data processing. Process partitioning is a scalable approach for coordinating work across a pool of independent workers.</summary>
    <content type="html">&lt;h2&gt;The problem&lt;/h2&gt;

&lt;p&gt;When working with large, high volume, low latency systems, it is often the case that processing data sequentially becomes detrimental to the system&amp;#39;s health. If we only allow 1 process to work on our data we run into several challenges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our process may fall behind resulting in a situation which it is impossible for our process to catch up.&lt;/li&gt;
&lt;li&gt;Our singleton process could crash and leave our system in a degraded state.&lt;/li&gt;
&lt;li&gt;The average latency of data processing could be dramatically affected by outlying cases.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For these reasons, we wish to design a system which allows N number of processes to work on a single data set. In order to arrive at a possible solution, let me outline some assumptions of the system.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A data store exists, containing items to be processed.&lt;/li&gt;
&lt;li&gt;The data store supports atomic updates or conditional puts.&lt;/li&gt;
&lt;li&gt;The system runs on a horizontally scalable platform that contains homogenous environment variables.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Solution&lt;/h2&gt;

&lt;p&gt;There are multiple approaches to processing data in parallel. By way of comparison let&amp;#39;s compare process partitioning with queuing, the most common solution to data processing.&lt;/p&gt;

&lt;h3&gt;Queuing&lt;/h3&gt;

&lt;p&gt;Queuing decouples data-processing workers from other system components and is a broadly accepted solution to processing data in parallel. However, there are certain scenarios where process partitioning is a better solution.&lt;/p&gt;

&lt;p&gt;Consider the case when your dataset lends itself to partitioning - in that the data has keys which are broadly spread across a wide value range. A partitioning scheme for such data can be created with minimal effort and allows us to keep the data-processing close to the data model itself. Another data abstraction, that of a queue, isn&amp;#39;t necessary in this case.&lt;/p&gt;

&lt;p&gt;Using queues also exposes you to the noisy-neighbor syndrome. If you have 25 jobs on the queue, all consisting of the same resource-intensive work, your queue could get bogged down while less intensive processing is blocked. Queues represent a false form of parallelism and are subject to such congestion.&lt;/p&gt;

&lt;p&gt;Queues may also not be appropriate when you have a high number of worker processes. Many workers accessing the same resource (the queue) can create a high contention rate. This threshold varies considerably considering the queue and langue being used, but be conscious of this limitation as your worker pool approaches 100 processes.&lt;/p&gt;

&lt;p&gt;In such cases process partitioning offers a less contentious way to access your data without requiring additional abstractions.&lt;/p&gt;

&lt;h3&gt;Process partitioning&lt;/h3&gt;

&lt;p&gt;Process partitioning approaches parallelism from a different angle. It creates logical shards of the dataset and assigns a single independent process to that subset of data. Since the data they access is unique to their process they&amp;#39;re not contending for a single resource and can more predictably scale to large numbers of processors.&lt;/p&gt;

&lt;p&gt;You could achieve similar benefit by using N queues (one per processor). However, an additional queue needs to be provisioned every time you want to increase the worker pool and you&amp;#39;re still left with an additional component to manage. In many cases process partitioning is an ideal solution.&lt;/p&gt;

&lt;p&gt;Our approach to process partitioning involves distributing the workload over N processors. Each processor will coordinate with a centralized data store to obtain an integer based identity. Thus each process will be identified by an integer from 0 to N. The processor will use it&amp;#39;s identity to exclusively find work. We will assign each item of work an integer value and the processor will select the item of work if the item&amp;#39;s value modulo N is equal to the processor&amp;#39;s id. Let us explore the details of our approach.&lt;/p&gt;

&lt;h2&gt;Identity coordination&lt;/h2&gt;

&lt;p&gt;Each processor should have access to N -- which is the maximum number of processors. N can be an environment variable defined in each processor&amp;#39;s memory. Upon initialization, each processor will successively choose a number from 0 to N until the processor can globally lock it&amp;#39;s identity. To lock an identity, each processor must request a lock on the identity with a central data store. The following code snippet is an example of identity coordination in Ruby:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;acquire_lock&lt;/span&gt;
  &lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;N&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;to_i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;times&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="ss"&gt;Locksmith&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="ss"&gt;:Dynamodb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;my-process-&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="k"&gt;yield&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;#critical section&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Tools such as &lt;a href="https://github.com/ryandotsmith/lock-smith"&gt;lock-smith&lt;/a&gt; and &lt;a href="https://github.com/ryandotsmith/ddbsync"&gt;ddbsync&lt;/a&gt; provide a convenient way to acquire a global lock as does native data store functionality such as Postgres&amp;#39; &lt;a href="http://www.postgresql.org/docs/9.1/static/functions-admin.html#FUNCTIONS-ADVISORY-LOCKS"&gt;pg_advisory_lock&lt;/a&gt; and MySQL&amp;#39;s &lt;a href="http://dev.mysql.com/doc/refman/5.5/en/miscellaneous-functions.html#function_get-lock"&gt;GET_LOCK&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Work item selection&lt;/h2&gt;

&lt;p&gt;Selecting data for each processor to process will be determined by the data store containing the items to be processed. Data stores supporting predicate analysis (e.g. SQL) will allow the processor to submit a query for data based on our modulo predicate. Data stores like Dynamodb will require the processor to scan data into memory and apply the predicates locally. You should take your data&amp;#39;s size into consideration when choosing the store for your items to be processed. Scanning the table into memory may not be feasible. An example of both approaches in Ruby:&lt;/p&gt;

&lt;h4&gt;SQL&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;acquire_lock&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="n"&gt;sql&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;select * from items_to_be_processed where MOD(id, ?) = ?&amp;quot;&lt;/span&gt;
  &lt;span class="no"&gt;DB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sql&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;N&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;In-memory scan&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;acquire_lock&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="no"&gt;DB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;N&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Non-integer identities&lt;/h4&gt;

&lt;p&gt;One caveat with the previous examples... It may not always be possible to have an integer based identity on your items-to-be-processed. In these cases we can use the CRC-32 algorithm to produce an checksum of the bytes of data and use the checksum in our modulo computation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;acquire_lock&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="no"&gt;DB&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="no"&gt;Zlib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;crc32&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;Integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;ENV&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;N&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Fault tolerance&lt;/h2&gt;

&lt;p&gt;In order to address the problem of maximizing the availability of our processors, we need only keep redundant processor online. If a processor should fail, it&amp;#39;s lock will be released allowing a redundant processor to acquire the lock in the identity coordination phase. For critical systems, keeping 2*N processors should be sufficient.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Process partitioning provides a way to process great amounts of data in parallel. It offers a simple design that can be implemented in any language on a variety of data stores. This approach is a great alternative to commonly seen queue based approaches. In fact, there are many cases in which this approach provides a greater level of concurrency which will allow a more robust data processing system. The proof of the concurrency improvements will be an exercise left to the reader.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Make Tests Unnecessary: Assert by Design</title>
    <link rel="alternate" href="http://miyagijournal.com/articles/7-make-tests-unnecessary-assert-by-design.html"/>
    <id>http://miyagijournal.comarticles/7-make-tests-unnecessary-assert-by-design.html</id>
    <published>2012-12-05T00:00:00-08:00</published>
    <updated>2012-12-05T00:00:00-08:00</updated>
    <author>
      <name>Pedro Belo</name>
    </author>
    <summary type="html">Automated testing is a proven tool for verifying application behavior and preventing bugs and regressions. However, as a last-minute line of defense, testing can often be eschewed in favor of baking preventative behavior directly into the application design.</summary>
    <content type="html">&lt;p&gt;Sometimes tests are not the best tool to assert that code behaves the way it was intended to.&lt;/p&gt;

&lt;p&gt;Take SQL injection, for instance: When was the last time you wrote a test to make sure your web app is protected? Maybe back in the day when writing our own SQL layer wasn’t a complete idiotic idea. Or maybe last time Paul introduced a hole and you had to write a regression test because you just don’t trust the guy.&lt;/p&gt;

&lt;p&gt;Either way, the fact is that we just don’t see any TDD enthusiast writing a SQL injection test before establishing a connection.&lt;/p&gt;

&lt;p&gt;“Well,” they say, “my framework provides the protection. I should not be testing third party code!”&lt;/p&gt;

&lt;p&gt;What about the authentication system, then? Should we write integration tests for every single endpoint in the application, making sure they are applying the right access control rules? What about audit traces, metrics logging, page caching?&lt;/p&gt;

&lt;p&gt;Nick Kallen says “&lt;a href="http://pivotallabs.com/users/nick/blog/articles/272-access-control-permissions-in-rails"&gt;the biggest danger with Access Control rules is the possibility that a careless Programmer might forget to implement them&lt;/a&gt;”. Even with nice helpers, patterns for testing, and 100% coverage a careless programmer can still compromise your security, and there’s nothing we can do about this.&lt;/p&gt;

&lt;p&gt;Or is there?&lt;/p&gt;

&lt;p&gt;I feel pretty confident that my code is protected against SQL injection, despite not having a single test on this front. And the reason is simple: modern web applications are protected against most security vulnerabilities by design. Create a vanilla Rails application and you’ll have to go out of your way to introduce vulnerabilities. Modern ORMs don’t just provide security, they enforce it in their contract.&lt;/p&gt;

&lt;p&gt;There’s nothing preventing us from getting the same kind of reassurance on other day-to-day issues: Design an authentication mechanism where it’s impossible to allow access without implementing a rule; introduce a pattern so users can’t perform actions without leaving an audit trace; consider open sourcing your design, when other programmers are clients you start thinking about design and contracts from another perspective.&lt;/p&gt;

&lt;p&gt;Well designed code will never substitute testing, but does give you the reassurance that no code coverage can match.&lt;/p&gt;

&lt;p&gt;Don&amp;#39;t test for the proper development practices, codify them.&lt;/p&gt;
</content>
  </entry>
</feed>
